
cbuffer MaterialBuffer
{
    float4 diffuseColor;
    float4 specularColor;
	float4 selfIluminationColor;
    float specularPower;
	float opacity;
	int subtype;
};

struct PixelInputType
{
    float4 position : SV_POSITION;
    float3 normal : NORMAL0;
    float3 viewDirection : NORMAL1;
	float3 worldPos: TEXCOORD1;
};

#define COLOR_SPECULAR 1
#define COLOR_SELFILUM 2
#define COLOR_TRANSPARENT 4

#define POSITION 0
#define DIFFUSE 1
#define NORMAL 2
#define SPECULAR 3
#define VIEW_DIRECTION 4
#define SELF_ILUM 5

struct PixelOutputType
{
    float4 position : SV_Target0;
    float4 diffuse : SV_Target1;
	float4 normal : SV_Target2;
	float4 specular : SV_Target3;
	float4 viewDirection : SV_Target4;
	float4 selfIlum : SV_Target5;
};

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
PixelOutputType ColorPixelShader(PixelInputType input) : SV_TARGET
{
	PixelOutputType output;
	
	output.position = float4(input.worldPos, 1.0f);
	
    // Sample the pixel color from the texture using the sampler at this texture coordinate location.
    output.diffuse = diffuseColor;
	output.normal.xyz = input.normal;
	output.normal.w = 1 - input.position.z / input.position.w; //inverted depth
	
	if (subtype & COLOR_SPECULAR) {
		output.specular.xyz = specularColor;
		output.specular.w = specularPower;
		output.viewDirection.xyz = input.viewDirection;
	}
	
	if (subtype & COLOR_SELFILUM)
		output.selfIlum = selfIluminationColor;
	
	
	if (subtype & COLOR_TRANSPARENT)
		 output.diffuse.w = opacity;
	
    return output;
}
